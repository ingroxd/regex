IP
dec "^((2([0-4][0-9]|5[0-5])|1?[1-9]?[0-9])\.){3}((2([0-4][0-9]|5[0-5])|1?[1-9]?[0-9]))$"
cidr "^((2([0-4][0-9]|5[0-5])|1?[1-9]?[0-9])\.){3}((2([0-4][0-9]|5[0-5])|1?[1-9]?[0-9]))\/(3[0-2]|[12]?[0-9])$"
dec "^(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])\.(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])\.(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])\.(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])$"
		With (e.g.) ed you could return \1, \3, \5, and \7 to have respectively 1st, 2nd, 3rd and 4th byte.
cidr "^(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])\.(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])\.(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])\.(2([0-4][0-9]|5[0-5])|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12][0-9]|[0-9])$"
		As dec, plus \9 for cidr

DATE
yyyy/mm/dd "^[0-9][0-9][0-9][0-9]/(0[1-9]|1[0-2])/(0[1-9]|[1-2][0-9]|3[0-1])$"
mm/dd/yyyy "^(0[1-9]|1[0-2])/(0[1-9]|[1-2][0-9]|3[0-1])/[0-9][0-9][0-9][0-9]$"
dd/mm/yyyy "^(0[1-9]|[1-2][0-9]|3[0-1])/(0[1-9]|1[0-2])/[0-9][0-9][0-9][0-9]$"
